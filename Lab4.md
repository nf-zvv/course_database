# Лабораторная работа №4

## Задание

1. Для тестовой базы данных из ЛР№3 реализовать CRUD операции.
2. Реализовать операции выборки даных из нескольких связанных таблиц при помощи `JOIN`.
3. Подготовить отчёт, содержащий разработанные SQL запросы и результаты их выполнения.

## Пояснения

Одним из наиболее распространенных и фундаментальных способов управления данными в базах являются операции CRUD.

CRUD - это акроним от основных операций, проводимых над информацией в базах данных: Create ("создать"), Read ("прочитать"), Update ("обновить"), Delete ("удалить").

### Создание (Create)

Операция создания новых записей в базе данных - это ключевой шаг для ввода новых данных в базу. При создании записей новая информация добавляется в хранилище. Для этой цели используется оператор `INSERT` в языке SQL.

SQL-запрос для добавления новой записи:

```sql
INSERT INTO Users (username, email) VALUES (?, ?);
```

### Чтение (Read)

Операция чтения данных из базы данных имеет критическое значение для получения информации из хранилища.

Для выполнения операции чтения используется оператор `SELECT` в языке SQL.

SQL-запрос чтения данных:

```sql
SELECT * FROM Users;
```

### Обновление (Update)

Операция обновления данных в базе имеет важное значение для поддержания актуальности информации.

Для выполнения операции обновления используется оператор `UPDATE` в языке SQL.

SQL-запрос обновления данных:

```sql
UPDATE Users SET email = ? WHERE username = ?;
```

### Удаление (Delete)

Удаление записей позволяет избавиться от данных, которые больше не актуальны или не нужны.

Для выполнения операции удаления используется оператор `DELETE` в языке SQL.

SQL-запрос удаления данных:

```sql
DELETE FROM Users WHERE username = ?;
```

### Объединения (Join)

JOIN - это мощный инструмент, позволяющий объединять данные из нескольких таблиц на основе соответствия критериям.

Объединения формируют основу для ответов на сложные вопросы о данных, что в конечном итоге повышает функциональность и расширяет возможности веб-приложений.

В зависимости от требований к результату, MySQL позволяет производить три разных типа объединения:

- INNER JOIN (CROSS JOIN) - внутреннее (перекрёстное) объединение;
- LEFT JOIN - левостороннее внешнее объединение;
- RIGHT JOIN - правостороннее внешнее объединение.

#### INNER JOIN (CROSS JOIN) - внутреннее (перекрёстное) объединение

Этот тип объединения позволяет извлекать строки, которые обязательно присутствуют во всех объединяемых таблицах.

В простейшем случае (без указания условий отбора), выборка вернёт т.н. декартово произведение (пересечение между двумя наборами данных), в котором каждая строка одной таблицы будет сопоставлена с каждой строкой другой таблицы.

Применение: Это наиболее распространённый тип объединения, идеально подходящий для сценариев, в которых вам нужны только данные с соответствующими записями в обеих таблицах. Например, получение данных о клиенте вместе с соответствующей информацией о заказе из разных таблиц.

Пример: получить список клиентов вместе с данными о последнем заказе (дата заказа). Интересуют только те клиенты, которые оформили хотя бы один заказ.

SQL-запрос:

```sql
SELECT c.customer_id, c.customer_name, c.email, o.order_date
FROM customers AS c
INNER JOIN orders AS o ON c.customer_id = o.customer_id
ORDER BY o.order_date DESC;
```

#### LEFT JOIN - Левостороннее внешнее объединение

Левосторонние объединения позволяют извлекать данные из левой таблицы (указанной первой), дополняя их по возможности данными из другой (правой) таблицы. Если для определённой строки в левой таблице не найдено совпадений, соответствующие столбцы правой таблицы будут заполнены значениями `NULL`.

Применение: Идеально подходит для ситуаций, когда необходимо сохранить все данные из левой таблицы, даже если в правой таблице нет соответствующих данных. Например, отображение списка всех пользователей, даже тех, кто ещё не сделал ни одного заказа.

Пример: необходимо отобразить список всех клиентов, включая тех, кто ещё не сделал ни одного заказа.

SQL-запрос:

```sql
SELECT c.customer_id, c.customer_name, c.email, o.order_date
FROM customers AS c
LEFT JOIN orders AS o ON c.customer_id = o.customer_id
ORDER BY c.customer_id;
```

Ключевое отличие заключается в использовании `LEFT JOIN` вместо `INNER JOIN`. Вот что происходит:

- Клиенты с заказами: В строках, где есть совпадение в обеих таблицах, будет отображаться вся информация из обеих таблиц, как и в примере `INNER JOIN`.
- Клиенты без заказов: Для клиентов, не сделавших ни одного заказа, соответствующие столбцы из таблицы `orders` (например, `order_date`) будут заполнены значениями `NULL`, что обеспечит включение всех клиентов в набор результатов.

`LEFT JOIN` эффективно демонстрирует, как отобразить все данные из левой таблицы (`customers`), независимо от того, есть ли соответствующие данные в правой таблице (`orders`).

#### RIGHT JOIN - Правостороннее внешнее объединение

Этот вид объединений практически ничем не отличается от левостороннего объединения, за тем исключением, что данные берутся из второй таблицы, которая находится справа от конструкции JOIN, и сравниваются с данными, которые находятся в таблице, указанной перед конструкцией.

Применение: Используйте это объединение, когда необходимо установить приоритет данных из правой таблицы и включить любую релевантную информацию из левой таблицы, если она существует. Представьте, что вам нужно получить подробные сведения обо всех товарах вместе с соответствующей информацией о заказе (если таковой имеется).

Пример: получить список всех товаров, включая те, которые ещё не были заказаны. Приоритет отдаётся отображению всех товаров, даже если они ещё не были куплены.

SQL-запрос:

```sql
SELECT p.product_id, p.product_name, p.price, o.order_id, o.quantity
FROM products AS p
RIGHT JOIN orders AS o ON p.product_id = o.product_id;
```

Вот что получается в результате:

- Продукты с заказами: В строках, где есть совпадение в обеих таблицах, будет отображаться информация из обеих таблиц, показывая сведения о продукте и соответствующую информацию о заказе.
- Продукты без заказов: Для продуктов, которые не были заказаны, соответствующие столбцы из таблицы заказов (например, `order_id` и `quantity`) будут заполнены значениями `NULL`. Однако вся информация о товарах из таблицы products всё равно будет включена.

Это `RIGHT JOIN` эффективно демонстрирует, как приоритизировать данные из правой таблицы (`products`) и включить любую релевантную информацию из левой таблицы (`orders`), если она существует.
